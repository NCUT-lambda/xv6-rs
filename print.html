<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>xv6-riscv-doc</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">简介</a></li><li class="chapter-item expanded "><a href="demo.html"><strong aria-hidden="true">1.</strong> 功能演示</a></li><li class="chapter-item expanded "><a href="environment.html"><strong aria-hidden="true">2.</strong> 环境配置</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">项目设计</li><li class="chapter-item expanded "><a href="structure.html"><strong aria-hidden="true">3.</strong> 代码结构</a></li><li class="chapter-item expanded "><a href="up.html"><strong aria-hidden="true">4.</strong> 并发控制</a></li><li class="chapter-item expanded "><a href="memory.html"><strong aria-hidden="true">5.</strong> 存储管理</a></li><li class="chapter-item expanded "><a href="process.html"><strong aria-hidden="true">6.</strong> 进程管理</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">总结</li><li class="chapter-item expanded "><a href="conclusion.html"><strong aria-hidden="true">7.</strong> 总结与期望</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="reference.html">参考资料</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">xv6-riscv-doc</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>本项目为从零开始使用 Rust 语言重新实现 xv6。</p>
<h2 id="项目进度"><a class="header" href="#项目进度">项目进度</a></h2>
<ul>
<li>
<p>移植 RustSBI</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
使用 RustSBI 启动内核</li>
</ul>
</li>
<li>
<p>锁</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
自旋锁</li>
<li><input disabled="" type="checkbox" checked=""/>
睡眠锁</li>
</ul>
</li>
<li>
<p>存储管理</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
物理页分配</li>
<li><input disabled="" type="checkbox" checked=""/>
Rust 全局分配器</li>
<li><input disabled="" type="checkbox" checked=""/>
虚拟存储</li>
</ul>
</li>
<li>
<p>进程管理</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
从 ELF 文件创建进程</li>
<li><input disabled="" type="checkbox" checked=""/>
进程调度</li>
</ul>
</li>
<li>
<p>陷入处理</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
系统调用 (部分)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="功能演示"><a class="header" href="#功能演示">功能演示</a></h1>
<p>目前基于 RustSBI 的 <code>console_getchar</code> 接口，实现了系统调用 <code>read</code>。并实现了一个用户程序 <code>sh</code>，其功能是接受用户输入的一行字符串，然后重新输出这个字符串。</p>
<pre><code>[rustsbi] RustSBI version 0.3.0-alpha.4, adapting to RISC-V SBI v1.0.0
.______       __    __      _______.___________.  _______..______   __
|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |
|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|
[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2
[rustsbi] Platform Name      : riscv-virtio,qemu
[rustsbi] Platform SMP       : 3
[rustsbi] Platform Memory    : 0x80000000..0x88000000
[rustsbi] Boot HART          : 0
[rustsbi] Device Tree Region : 0x87000000..0x8700117a
[rustsbi] Firmware Address   : 0x80000000
[rustsbi] Supervisor Address : 0x80200000
[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)
[rustsbi] pmp02: 0x80000000..0x80200000 (---)
[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)
[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)
__  ____     ____         ____  _   _ ____ _____ 
\ \/ /\ \   / / /_       |  _ \| | | / ___|_   _|
 \  /  \ \ / / '_ \ _____| |_) | | | \___ \ | |  
 /  \   \ V /| (_) |_____|  _ &lt;| |_| |___) || |  
/_/\_\   \_/  \___/      |_| \_\\___/|____/ |_|  
                                                 
    where there is a shell, there is a way

xv6-rust kernel is booting...

$ hello world
hello world
$ shell
shell
$ xv6-rust
xv6-rust
$ 
</code></pre>
<h2 id="视频演示"><a class="header" href="#视频演示">视频演示</a></h2>
<p><video src="images/MP4_20230815_104140VLOG.mp4">演示视频</video></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h1>
<h2 id="c-环境"><a class="header" href="#c-环境">C 环境</a></h2>
<pre><code>sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu
</code></pre>
<h2 id="rust-环境"><a class="header" href="#rust-环境">Rust 环境</a></h2>
<pre><code>curl https://sh.rustup.rs -sSf | sh
</code></pre>
<h3 id="rust-nightly"><a class="header" href="#rust-nightly">Rust nightly</a></h3>
<pre><code>rustup install nightly
rustup default nightly
</code></pre>
<h3 id="更改-cargo-镜像地址"><a class="header" href="#更改-cargo-镜像地址">更改 cargo 镜像地址</a></h3>
<p>将 <code>~/.cargo/config</code> 里的内容改为如下：</p>
<pre><code>[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;
replace-with = 'ustc'
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;
</code></pre>
<h3 id="rust-相关软件包"><a class="header" href="#rust-相关软件包">Rust 相关软件包</a></h3>
<pre><code>rustup target add riscv64gc-unknown-none-elf
cargo install cargo-binutils
rustup component add llvm-tools-preview
rustup component add rust-src
</code></pre>
<h2 id="qemu-环境"><a class="header" href="#qemu-环境">QEMU 环境</a></h2>
<p>默认使用的 qemu 版本为 7.0.0</p>
<h3 id="下载源码包并手动编译"><a class="header" href="#下载源码包并手动编译">下载源码包并手动编译</a></h3>
<pre><code># 安装编译所需的依赖包
sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \
              gawk build-essential bison flex texinfo gperf libtool patchutils bc \
              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev libsdl2-dev \
              git tmux python3 python3-pip ninja-build
# 下载源码包
wget https://download.qemu.org/qemu-7.0.0.tar.xz
# 解压
tar xvJf qemu-7.0.0.tar.xz
# 编译安装并配置 RISC-V 支持
cd qemu-7.0.0
./configure --target-list=riscv64-softmmu,riscv64-linux-user  # 如果要支持图形界面，可添加 &quot; --enable-sdl&quot; 参数
make -j$(nproc)
</code></pre>
<h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<pre><code>sudo make install
</code></pre>
<h2 id="gdb"><a class="header" href="#gdb">gdb</a></h2>
<p>使用 <code>gdb-multiarch</code> 即可</p>
<pre><code>sudo apt-get install gdb-multiarch
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码结构"><a class="header" href="#代码结构">代码结构</a></h1>
<pre><code>.
├── bootloader
│   └── rustsbi-qemu.bin
├── kernel
│   ├── build.rs
│   ├── Cargo.toml
│   ├── Makefile
│   └── src
│       ├── allocator
│       │   └── mod.rs
│       ├── console.rs
│       ├── driver
│       │   ├── mod.rs
│       │   └── virtio_disk.rs
│       ├── entry.S
│       ├── exec
│       │   ├── apps.rs
│       │   ├── elf.rs
│       │   └── mod.rs
│       ├── fs
│       │   ├── buf.rs
│       │   ├── file.rs
│       │   ├── inode.rs
│       │   ├── log.rs
│       │   ├── mod.rs
│       │   └── pipe.rs
│       ├── kernel.ld
│       ├── lang_items.rs
│       ├── lock
│       │   ├── mod.rs
│       │   ├── sleeplock.rs
│       │   └── spinlock.rs
│       ├── logo
│       │   ├── logo
│       │   └── mod.rs
│       ├── main.rs
│       ├── memory
│       │   ├── kalloc.rs
│       │   ├── kvm.rs
│       │   ├── memlayout.rs
│       │   ├── mod.rs
│       │   ├── pagetable.rs
│       │   └── uvm.rs
│       ├── param.rs
│       ├── printf.rs
│       ├── process
│       │   ├── context.rs
│       │   ├── cpu.rs
│       │   ├── mod.rs
│       │   ├── proc.rs
│       │   └── switch.S
│       ├── riscv.rs
│       ├── sbi.rs
│       ├── string.rs
│       ├── sync
│       │   ├── mod.rs
│       │   └── upcell.rs
│       ├── syscall
│       │   ├── mod.rs
│       │   ├── sysfile.rs
│       │   └── sysproc.rs
│       └── trap
│           ├── kernelvec.S
│           ├── mod.rs
│           ├── plic.rs
│           ├── trampoline.S
│           └── trapframe.rs
├── Makefile
└── user
    ├── Cargo.toml
    ├── Makefile
    └── src
        ├── bin
        │   └── sh.rs
        ├── console.rs
        ├── lang_items.rs
        ├── lib.rs
        ├── syscall.rs
        └── user.ld
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发控制"><a class="header" href="#并发控制">并发控制</a></h1>
<h2 id="多线程容器"><a class="header" href="#多线程容器">多线程容器</a></h2>
<p>在 Rust 中对可变静态变量的访问是不安全的，直接使用会导致代码中很多 <code>unsafe</code> 块。所以我们需要一个具有内部可变性的容器，将静态变量包含起来，来实现对静态变量的安全访问。<br />
实际上在 Rust 库中已经实现了类似的实现如 <code>RefCell</code>和<code>UnSafeCell</code>，<code>RefCell</code> 由于多个可变引用存在时会 <code>panic</code>，无法实现更加精细的并发控制，<code>UnSafeCell</code> 在多线程下是不安全的。<br />
所以我们使用 <code>UnSafeCell</code> 封装成容器 <code>UPCell</code> ，并为其实现 <code>trait Sync</code>，就可以在多线程中访问，同时允许多个可变借用存在。其实现如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UPCell&lt;T&gt; {
    data: UnsafeCell&lt;T&gt;,
}

unsafe impl&lt;T&gt; Sync for UPCell&lt;T&gt; {}
unsafe impl&lt;T&gt; Send for UPCell&lt;T&gt; {}

impl&lt;T&gt; UPCell&lt;T&gt; {
    pub fn new(value: T) -&gt; Self {
        Self {
            data: UnsafeCell::new(value),
        }
    }

    pub fn get(&amp;self) -&gt; *mut T {
        self.data.get()
    }

    pub fn get_mut(&amp;self) -&gt; &amp;mut T {
        unsafe { &amp;mut *self.data.get() }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>实际上这个容器在多线程下也是不安全的，因为它允许多个可变借用存在，但这也是我们的目的。所以对于容器内部结构体中的可能会发生数据竞争的变量，需要通过加锁来避免数据竞争。<br />
通过组合使用 <code>UPCell</code> 和 自旋锁，可以提高程序的可并发性。</p>
<h2 id="自旋锁"><a class="header" href="#自旋锁">自旋锁</a></h2>
<p>为了使锁的粒度尽量小，这里我们使用了和 xv6 同样风格的锁。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Spinlock {
    locked: AtomicBool,

    // 用于调试
    name: &amp;'static str,
    cpu: *mut Cpu,
}
<span class="boring">}</span></code></pre></pre>
<p>我们使用 Rust 中的原子类型 <code>AtomicBool</code> 的两个原子方法<code>compare_exchange</code> 和 <code>store</code> 来保证锁的获取和释放操作是原子性的。同时通过 <code>fence(Ordering::SeqCst)</code> 设置内存屏障来保证 cpu 或编译器不会将这个屏障后的指令优化到前面执行。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn acquire(&amp;mut self) {
    push_off(); // 关中断，避免死锁
    if self.holding() {
        panic!(&quot;acquire&quot;);
    }

    while self
        .locked
        .compare_exchange(false, true, Ordering::Acquire, Ordering::Acquire)
        .is_err()
    {} // 自旋等待
    fence(Ordering::SeqCst);

    self.cpu = mycpu();
}

pub fn release(&amp;mut self) {
    if !self.holding() {
        panic!(&quot;release&quot;);
    }

    self.cpu = null_mut();

    fence(Ordering::SeqCst);

    self.locked.store(false, Ordering::Release);

    pop_off();
}
<span class="boring">}</span></code></pre></pre>
<p>同时还应该注意到，在上述代码中，有两个额外的操作 <code>push_off</code> 和 <code>pop_off</code>。考虑当 <code>aquire</code> 或 <code>release</code> 时，如果发生中断，则可能会导致一个锁被多个 cpu 持有或者被多次释放，所以要保证获取锁和释放锁时中断处于关闭状态，并且还要在操作结束后恢复原来的中断状态，所以就有了如下的实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn push_off() {
    let old = intr_get();

    intr_off();
    let mut mc = unsafe { &amp;mut *mycpu() };

    // 第一次 push_off，需要记录之前的中断开启状态
    if mc.noff == 0 {
        mc.intena = old;
    }
    mc.noff += 1;
}

pub fn pop_off() {
    let mc: &amp;mut Cpu = unsafe { &amp;mut *mycpu() };
    if intr_get() {
        panic!(&quot;pop_off - interruptible&quot;);
    }
    if mc.noff &lt; 1 {
        panic!(&quot;pop_off {}&quot;, mc.noff);
    }
    mc.noff -= 1;
    if mc.noff == 0 &amp;&amp; mc.intena {
        intr_on();
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="睡眠锁"><a class="header" href="#睡眠锁">睡眠锁</a></h2>
<p>睡眠锁主要用于需要长时间处理的资源的互斥访问，如磁盘读写。当一个睡眠锁被一个进程持有之后，后续试图获取这个锁的进程会进入休眠状态，从而避免了<code>自旋锁</code>那样的忙等。<br />
其实现如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Sleeplock {
    locked: bool, // 此锁是否被持有
    lk: Spinlock, // 用于保护此锁的自旋锁

    // 用于调试
    name: &amp;'static str, // 锁的名字
    pid: usize,         // 拥有锁的进程
}

pub fn acquire(&amp;mut self) {
    self.lk.acquire();
    while self.locked {
        sleep(self as *mut Sleeplock, &amp;mut self.lk);
    }
    self.locked = true;
    let p = unsafe {  &amp; *myproc()};
    self.pid = p.pid;
    self.lk.release();
}

pub fn release(&amp;mut self) {
    self.lk.acquire();
    self.locked = false;
    self.pid = 0;
    wakeup(self as *mut Sleeplock);
    self.lk.release();
}
<span class="boring">}</span></code></pre></pre>
<p>在实现睡眠锁时要注意两个问题：</p>
<ol>
<li>避免唤醒丢失的问题</li>
<li>避免出现死锁</li>
</ol>
<p>考虑下面一种情况：</p>
<ul>
<li>现有一把睡眠锁 lk 被进程 A 持有，进程 B 尝试获取 lk 失败，所以会进入睡眠，在它即将进入睡眠状态之前，进程 A 释放了 lk，由于这个时候进程 B 还没有完全进入睡眠状态，所以进程 A 不会释放进程 B，在 B 彻底进入睡眠状态后就无人将它唤醒了，所以这种问题也就是唤醒丢失问题。</li>
</ul>
<p>很容易发现上述问题是由于睡眠操作和唤醒操作的非互斥进行造成的，所以我们在 <code>Sleeplock</code> 中加入了一个 <code>Spinlock</code> 来保证 <code>sleep()</code> 和 <code>wakeup()</code> 的原子性。但这样也引入了另外一个问题。</p>
<ul>
<li>当进程进入睡眠状态时，会带着持有的 <code>lk</code> 一起进入睡眠，所以后续进程也就无法使用 <code>lk</code>，从而导致死锁。</li>
</ul>
<p>实际上在 <code>sleep()</code> 内部，会释放 <code>lk</code> 并通过另一把进程锁 <code>p-&gt;lock</code> 来接替 <code>lk</code> 的任务，并且 <code>p-&gt;lock</code> 是会自动释放的，这样就避免了死锁的产生。在 <code>walkeup()</code> 中的实现也是类似的。</p>
<p>所以我们巧妙地使用了两把 <code>Spinlock</code> 来实现了 <code>Sleeplock</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存储管理"><a class="header" href="#存储管理">存储管理</a></h1>
<h2 id="全局分配器"><a class="header" href="#全局分配器">全局分配器</a></h2>
<p>为了在内核中能够使用 <code>String</code>, <code>Vec</code> 等动态内存分配的容器，需要实现 <code>global_allocator</code>，为此我们直接使用的现有的 <code>buddy_system_allocator</code> 来实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[global_allocator]
static HEAP_ALLOCATOR: LockedHeap = LockedHeap::empty();
<span class="boring">}</span></code></pre></pre>
<h2 id="物理页分配"><a class="header" href="#物理页分配">物理页分配</a></h2>
<p>我们对空闲页面的管理方式和 xv6 相同，即链式管理。由于链表的所有结点信息都存储在空闲页面里面，所以这种管理方式的优点就是<strong>没有额外的内存开销</strong>。</p>
<p>在内核初始化时，会扫描所有的空闲物理页面，然后组成一个空闲页面链表。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Kmem {
    lock: Spinlock,
    freelist: *mut Run,
}

pub fn kinit() {
    KMEM.get_mut().freerange(ekernel as Addr, PHYSTOP);
    // println!(&quot;kinit success!&quot;);
}
fn freerange(&amp;mut self, pa_start: Addr, pa_end: Addr) {
    let mut pa = pgroundup(pa_start);
    while pa &lt; pa_end - PGSIZE {
        self.kfree(pa);
        pa += PGSIZE;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>kalloc()</code> 会从单向空闲页面链表的表头，找到一个可用的空闲页面，如果找到就返回这个地址，否则就会返回一个空指针。</p>
<p><code>kfree()</code> 会回收一个地址为 <code>pa</code> 的物理页面。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn kfree(&amp;mut self, pa: Addr) {
    if pa % PGSIZE != 0 || pa &lt; ekernel as Addr || pa &gt;= PHYSTOP {
        panic!(&quot;kfree&quot;);
    }

    // 填充垃圾数据避免垂悬引用
    memset(pa as *mut u8, 1, PGSIZE);

    let pa = pa as *mut Run;
    self.lock.acquire();
    unsafe { (*pa).next = self.freelist }
    self.freelist = pa;
    self.lock.release();
}

fn kalloc(&amp;mut self) -&gt; Addr {
    let mut r: *mut Run = null_mut();

    self.lock.acquire();
    r = self.freelist;
    if r != null_mut() {
        unsafe { self.freelist = (*r).next }
    }
    self.lock.release();

    if r != null_mut() {
        memset(r as *mut u8, 5, PGSIZE);
    }

    r as Addr
}
<span class="boring">}</span></code></pre></pre>
<p>当然目前的这种单向链表管理方式也存在一些问题：</p>
<ul>
<li>没必要在初始化时扫描所有内存，而仅需额外增加一个变量 next 表示下次分配的物理页面的地址，在释放页面时才逐步地建立起来空闲页面链表。</li>
<li>单向空闲页面链表会存在<strong>部分页面频繁使用，而部分页面几乎从不使用</strong>的情况，可以使用双向链表改进。</li>
</ul>
<p>后续会对上述存在的问题进行改进。</p>
<h2 id="虚拟存储"><a class="header" href="#虚拟存储">虚拟存储</a></h2>
<p>我们虚拟存储的实现基本与 xv6 保持一致。</p>
<p>对于内核地址空间，我们采用恒等映射的方式。</p>
<p><img src="./images/image-20230603155354857.png" alt="image-20230603155354857" /></p>
<p>对于用户地址空间，我们将其映射到地址 0x0 处。</p>
<p><img src="./images/image-20230603155513900.png" alt="image-20230603155513900" /></p>
<h2 id="内核栈与用户栈"><a class="header" href="#内核栈与用户栈">内核栈与用户栈</a></h2>
<p>在实际运行测试过程发现一个页面大小的堆栈无法满足正常需求，有时在内核启动过程中会出现爆栈的情况，所以我们统一将内核的堆栈大小设置为 16 个页面，也就是 64K，而用户的堆栈大小设置为 4个页面，即 4K。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const KERNEL_STACK_SIZE: usize = 16 * PGSIZE;
pub const USER_STACK_SIZE: usize = 4 * PGSIZE;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进程管理"><a class="header" href="#进程管理">进程管理</a></h1>
<p>目前的进程结构的实现与 xv6 保持一致。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Proc {
    pub lock: Spinlock,

    // 当使用这些时必须持有 p-&gt;lock
    pub state: ProcState, // 进程状态
    chan: *mut u8,    // 如果非空，处于休眠态并等待睡眠锁 chan
    killed: bool,     // 如果为 true，进程被杀死
    xstate: isize,    // 退出时的状态，会返回给正在等待的父进程
    pub pid: usize,   // 进程号

    // 当使用这个域时必须持有 wait_lock
    parent: *mut Proc, // 父进程

    // 这些是进程的私有属性，不必持有 p-&gt;lock
    pub kstack: Addr,              // 内核栈的虚拟地址
    pub sz: usize,                     // 进程占用内存大小 (单位: 字节)
    pub uvm: Uvm,                  // 进程页表
    pub trapframe: *mut Trapframe, // 用于切换到内核时保存用户信息
    context: Context,              // swtch() 从这切换进程
    ofile: [*mut File; NOFILE],    // 打开的文件
    cwd: *mut Inode,               // 当前工作目录
    pub name: String,              // 进程名
}
<span class="boring">}</span></code></pre></pre>
<h2 id="shell-程序"><a class="header" href="#shell-程序">shell 程序</a></h2>
<p>由于目前尚未实现文件系统，所以我们实现了一个简单的用户程序 <code>sh</code> 来测试进程相关的功能，并把 <code>sh</code> 编译得到的 <code>elf</code> 格式可执行文件硬链接进入内核的数据段，这样可以直接从内核加载用户程序并启动。</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
    ...
    exec_app(&quot;sh&quot;);
    ...
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="总结与期望"><a class="header" href="#总结与期望">总结与期望</a></h1>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>目前 xv6 的主体部分，包括内存管理和进程管理，已经基本实现。</p>
<p>并且可以正常运行用户程序。</p>
<h2 id="期望"><a class="header" href="#期望">期望</a></h2>
<ul>
<li>继续完成后续的内核移植工作，主要为文件系统。</li>
<li>移植 xv6 的用户程序。</li>
<li>让代码风格更加 <code>rusty</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h1>
<ul>
<li><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/index.html">rCore-Tutorial-Book 第三版</a></li>
<li><a href="https://course.rs/about-book.html">Rust语言圣经</a></li>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a></li>
<li><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/">MIT6.S081中文文档</a></li>
<li><a href="https://github.com/Ko-oK-OS/xv6-rust">xv6-rust</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
